<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>í•™ìƒ ë§ˆì´í˜ì´ì§€ - ë¸”ë¼ì¸ì‰ê¸€ë¦¬ì‰¬</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://cdn.jsdelivr.net/npm/pretendard/dist/web/variable/pretendardvariable.css" rel="stylesheet" />

  <style>
    /* === [ê³µí†µ ìŠ¤íƒ€ì¼] ë¸”ë¼ì¸ í‘œì¤€ ë””ìì¸ === */
    :root {
      --blue: #00AEEF;
      --mint: #9FE6B8;
      --pink: #FF6FB5;
      --gray-bg: #e5e7eb;
      --gray-text: #374151;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; font-family: "Pretendard Variable", sans-serif; }
    
    body { 
      background: #f4f6fb; 
      /* âœ… ì„ ìƒë‹˜ í˜ì´ì§€ì™€ ë™ì¼í•œ ìƒë‹¨ ì—¬ë°± (30px) */
      padding: 30px 0 60px; 
      color: #111827; 
    }

    .page { max-width: 1100px; margin: 0 auto; padding: 0 20px; }

    /* --- [1ë‹¨] ìƒë‹¨ íƒ€ì´í‹€ ì˜ì—­ --- */
    .title-big {
      font-size: 34px;
      font-weight: 900;
      color: #111;
      margin-bottom: 6px;
    }

    .subtitle {
      font-size: 16px;
      color: #6b7280;
      margin-bottom: 20px;
    }

    /* --- [2ë‹¨] ìƒë‹¨ ë²„íŠ¼ ì¤„ (í‘œì¤€ ë„¤ë¹„ê²Œì´ì…˜) --- */
    .top-bar {
      display: flex;
      justify-content: flex-end; /* ì˜¤ë¥¸ìª½ ì •ë ¬ */
      align-items: center;
      margin-bottom: 18px;
      min-height: 40px;
    }

    .top-btns {
      display: flex;
      gap: 8px;
    }

    .nav-btn {
      padding: 8px 18px;
      border-radius: 999px;
      border: none;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
      transition: opacity 0.2s;
      text-decoration: none;
    }
    .nav-btn:hover { opacity: 0.9; }

    /* ë²„íŠ¼ë³„ ìƒ‰ìƒ */
    .btn-home { background: var(--gray-bg); color: var(--gray-text); }
    .btn-logout { background: var(--pink); color: #ffffff; }

    /* === [ì¹´ë“œ ê³µí†µ ìŠ¤íƒ€ì¼] === */
    .section-card { 
      background: white; 
      border-radius: 24px; /* ë‘¥ê¸€ê²Œ í†µì¼ */
      padding: 30px; /* ì—¬ë°± ë„‰ë„‰í•˜ê²Œ */
      margin-bottom: 24px; 
      box-shadow: 0 15px 32px rgba(15, 23, 42, 0.08); 
    }
    
    .section-header { margin-bottom: 20px; }
    
    .section-title { 
      font-size: 20px; 
      font-weight: 800; 
      color: #111;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .badge-small {
      display: inline-flex; align-items: center; padding: 2px 8px;
      border-radius: 999px; font-size: 12px; font-weight: 700;
      background: #e5e7eb; color: #4b5563;
    }

    /* === [ì…ë ¥ í¼ ìŠ¤íƒ€ì¼] ì„ ìƒë‹˜ í˜ì´ì§€ì™€ í†µì¼ === */
    .form-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 8px;
      align-items: flex-end;
    }

    .field { min-width: 140px; }

    .field label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      color: #4b5563;
      margin-bottom: 6px;
      margin-left: 4px;
    }

    .input, .input-date, select {
      width: 100%;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid #d1d5db;
      font-size: 14px;
      background: #ffffff;
      outline: none;
      transition: border-color 0.2s;
    }
    .input:focus, .input-date:focus, select:focus { border-color: var(--blue); }

    .wide-field { min-width: 260px; flex-grow: 1; }

    /* í† ê¸€ ë²„íŠ¼ ê·¸ë£¹ */
    .pill-group {
      display: inline-flex;
      background: #f3f4f6;
      border-radius: 999px;
      padding: 4px;
      gap: 4px;
      width: 100%;
      height: 42px;
      align-items: center;
      justify-content: center;
    }
    .pill-type-btn {
      border: none; border-radius: 999px; padding: 0 14px; height: 100%;
      font-size: 13px; font-weight: 600; cursor: pointer;
      background: transparent; color: #6b7280; flex: 1; transition: all 0.2s;
    }
    .pill-type-btn.active { background: var(--blue); color: #ffffff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

    /* ë©”ì¸ ë²„íŠ¼ë“¤ (ë“±ë¡/ê´€ë¦¬/ì·¨ì†Œ) */
    .actions-wrap {
      display: flex;
      gap: 8px;
    }
    
    .btn-block {
        height: 42px;
        border-radius: 12px;
        font-weight: 700;
        font-size: 14px;
        cursor: pointer;
        border: none;
        padding: 0 16px;
        white-space: nowrap;
        transition: opacity 0.2s;
    }
    .btn-block:hover { opacity: 0.9; }

    .btn-primary { background: var(--pink); color: white; flex: 2; }
    .btn-soft { background: var(--mint); color: white; flex: 1.5; }
    .btn-cancel { background: #e5e7eb; color: #374151; flex: 1; }

    /* ì–´íœ˜ ìƒì„¸ ì„¤ì • */
    .vocab-config { margin-top: 16px; display: none; }
    .preset-row { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
    .preset-btn {
        padding: 6px 12px; border: 1px solid #e5e7eb; background: #fff; 
        border-radius: 20px; font-size: 12px; font-weight: 600; cursor: pointer; color: #555;
    }
    .preset-btn:hover { background: #f9fafb; }

    .mini-select-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
    .mini-item {
        background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 12px;
        padding: 8px 12px; display: flex; align-items: center; justify-content: space-between;
    }
    .mini-item.off { opacity: 0.5; }
    .mini-label { font-size: 13px; font-weight: 700; color: #333; }
    .mini-select { width: auto; padding: 4px 8px; height: 30px; border-radius: 8px; font-size: 13px; }

    /* ìš°ë¦¬ë°˜ ìˆ™ì œ / ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
    .hw-group-card { background: #f9fafb; border-radius: 16px; padding: 16px; margin-bottom: 12px; border: 1px solid #eee; }
    .hw-group-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .hw-group-date { font-size: 16px; font-weight: 800; color: var(--blue); }
    .hw-group-meta { font-size: 12px; color: #888; }
    
    .chip { display: inline-flex; padding: 3px 8px; border-radius: 6px; font-size: 11px; font-weight: 700; margin-right: 6px; }
    .chip-class { background: #eef2ff; color: #3730a3; }
    .chip-online-vocab { background: #fee2e2; color: #b91c1c; }
    .chip-online-sentence { background: #e0f2fe; color: #0369a1; }
    .chip-warning { background: #fff7ed; color: #c2410c; }
    
    .hw-text-line { font-size: 14px; color: #333; margin: 4px 0; line-height: 1.5; }
    
    .class-hw-empty { text-align: center; color: #999; padding: 20px; font-size: 14px; background: #f9fafb; border-radius: 12px; }

    /* ë‚´ ê²°ê³¼ í…Œì´ë¸” */
    .unit-result-wrap { border: 1px solid #eee; border-radius: 16px; overflow: hidden; }
    .unit-result-head { display: grid; grid-template-columns: 1.2fr 0.8fr 0.8fr 1fr 0.6fr 1.2fr; background: #f9fafb; padding: 12px; font-size: 13px; font-weight: 700; color: #555; border-bottom: 1px solid #eee; }
    .unit-result-summary { display: grid; grid-template-columns: 1.2fr 0.8fr 0.8fr 1fr 0.6fr 1.2fr; padding: 12px; align-items: center; font-size: 13px; color: #333; cursor: pointer; border-bottom: 1px solid #eee; }
    .unit-result-summary:hover { background: #fcfcfc; }
    
    .status-pill { display: inline-flex; width: 24px; height: 24px; align-items: center; justify-content: center; border-radius: 50%; font-size: 12px; font-weight: 700; }
    .status-o { background: #dcfce7; color: #166534; }
    .status-x { background: #fee2e2; color: #991b1b; }
    .status-d { background: #fef3c7; color: #92400e; }

    .unit-detail { padding: 12px; background: #fff; border-bottom: 1px solid #eee; }
    .unit-detail-grid { display: grid; gap: 8px; background: #f9fafb; padding: 10px; border-radius: 12px; }
    .task-row { display: grid; grid-template-columns: 1fr 80px 120px; align-items: center; font-size: 13px; padding: 6px 0; border-bottom: 1px dashed #eee; }
    .task-row:last-child { border-bottom: none; }

    /* ëª¨ë‹¬ */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 999; }
    .modal { background: white; width: 90%; max-width: 600px; border-radius: 24px; overflow: hidden; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
    .modal-head { padding: 16px 20px; background: #f9fafb; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
    .modal-title { font-weight: 800; font-size: 16px; }
    .modal-body { padding: 20px; max-height: 70vh; overflow-y: auto; }
    
    .manage-table { width: 100%; border-collapse: collapse; font-size: 13px; }
    .manage-table th { text-align: left; padding: 10px; background: #f9fafb; color: #666; font-weight: 700; }
    .manage-table td { padding: 10px; border-bottom: 1px solid #eee; }
    .btn-mini { padding: 4px 8px; border-radius: 6px; font-size: 11px; border:none; cursor: pointer; font-weight: 700; margin-left: 4px; }
    .btn-edit { background: #e5e7eb; color: #333; }
    .btn-del { background: #fee2e2; color: #b91c1c; }

    .status-text { font-size: 13px; margin-top: 10px; color: #666; }
    .status-text.error { color: #b91c1c; font-weight: 700; }

    @media (max-width: 768px) {
        .mini-select-row { grid-template-columns: 1fr 1fr; }
        .unit-result-head, .unit-result-summary { grid-template-columns: 1fr 0.8fr 1.2fr 0.5fr; }
        .unit-result-head div:nth-child(2), .unit-result-head div:nth-child(6),
        .unit-result-summary div:nth-child(2), .unit-result-summary div:nth-child(6) { display: none; }
        .actions-wrap { flex-direction: column; }
    }
  </style>
</head>

<body>
<div class="page">
  <div class="title-big">í•™ìƒ ë§ˆì´í˜ì´ì§€</div>
  <div class="subtitle">
    ì˜¤ëŠ˜ ìˆ™ì œì™€ ì˜¨ë¼ì¸ í•™ìŠµ ê²°ê³¼ë¥¼ í•œ ê³³ì—ì„œ í™•ì¸í•´ ë³´ì„¸ìš”.
  </div>

  <div class="top-bar">
    <div class="top-btns">
      <button id="home-btn" class="nav-btn btn-home" type="button">ğŸ  Home</button>
      <button id="logout-btn" class="nav-btn btn-logout" type="button">ë¡œê·¸ì•„ì›ƒ</button>
    </div>
  </div>

  <div class="section-card">
    <div class="section-header">
      <div class="section-title">
        ğŸ“š ìš°ë¦¬ ë°˜ ìˆ™ì œ
        <span id="class-badge" class="badge-small">-</span>
      </div>
    </div>
    <div id="class-hw-area"></div>
  </div>

  <div class="section-card">
    <div class="section-header">
      <div class="section-title">âœï¸ ë‚´ ì˜¨ë¼ì¸ ìˆ™ì œ ë§Œë“¤ê¸°</div>
    </div>

    <div class="form-row">
      <div class="field" style="min-width:140px;">
        <label>ìˆ™ì œ ì¢…ë¥˜</label>
        <div class="pill-group">
          <button type="button" id="type-vocab" class="pill-type-btn active">ì–´íœ˜</button>
          <button type="button" id="type-sentence" class="pill-type-btn">ë¬¸ì¥</button>
        </div>
      </div>

      <div class="field wide-field">
        <label>ë‹¨ê³„-ì„¸íŠ¸ (ì˜ˆ: 1-1 ë˜ëŠ” ì ì‹ ì¤‘1-1)</label>
        <input id="my-hw-set" class="input" type="text" placeholder="ì˜ˆ: 1-1 ë˜ëŠ” 1-1, 1-2" />
      </div>

      <div class="field" style="min-width:140px;">
        <label>ë§ˆê°ì¼</label>
        <input id="my-hw-due" class="input-date" type="date" />
      </div>

      <div class="field actions-wrap" style="flex-grow: 1; max-width: 300px;">
        <label style="visibility:hidden;">ë²„íŠ¼</label>
        <button id="my-hw-save-btn" class="btn-block btn-primary" type="button">ìˆ™ì œ ë“±ë¡</button>
        <button id="my-hw-manage-btn" class="btn-block btn-soft" type="button">ìˆ™ì œ ê´€ë¦¬</button>
        <button id="my-hw-cancel-btn" class="btn-block btn-cancel" type="button" style="display:none;">ì·¨ì†Œ</button>
      </div>
    </div>

    <div id="vocab-config" class="vocab-config">
      <div class="preset-row">
        <button type="button" id="preset-default" class="preset-btn">ê¸°ë³¸ 4ì¢…</button>
        <button type="button" id="preset-blank3" class="preset-btn">ë¬¸ì¥ ë¹ˆì¹¸ Ã—3</button>
        <button type="button" id="preset-reset" class="preset-btn">ì´ˆê¸°í™”</button>
      </div>

      <div class="mini-select-row">
        <div class="mini-item" id="mini-meaning">
          <div class="mini-label">ëœ» ì°¾ê¸°</div>
          <select id="sel-meaning" class="mini-select">
            <option value="0">0</option><option value="1">1</option><option value="2">2</option>
            <option value="3">3</option><option value="4">4</option><option value="5">5</option>
          </select>
        </div>
        <div class="mini-item" id="mini-english">
          <div class="mini-label">ì˜ì–´ ì°¾ê¸°</div>
          <select id="sel-english" class="mini-select">
            <option value="0">0</option><option value="1">1</option><option value="2">2</option>
            <option value="3">3</option><option value="4">4</option><option value="5">5</option>
          </select>
        </div>
        <div class="mini-item" id="mini-listening">
          <div class="mini-label">ë“£ê³  ì°¾ê¸°</div>
          <select id="sel-listening" class="mini-select">
            <option value="0">0</option><option value="1">1</option><option value="2">2</option>
            <option value="3">3</option><option value="4">4</option><option value="5">5</option>
          </select>
        </div>
        <div class="mini-item" id="mini-sentence">
          <div class="mini-label">ë¬¸ì¥ ë¹ˆì¹¸</div>
          <select id="sel-sentence" class="mini-select">
            <option value="0">0</option><option value="1">1</option><option value="2">2</option>
            <option value="3">3</option><option value="4">4</option><option value="5">5</option>
          </select>
        </div>
      </div>
    </div>

    <div style="font-size:12px; color:#999; margin-top:10px;">
      * ì–´íœ˜ëŠ” ê°™ì€ ë‹¨ê³„ë§Œ ì—¬ëŸ¬ ê°œ ì…ë ¥ ê°€ëŠ¥(ì˜ˆ: 1-1, 1-2). ë¬¸ì¥ì€ 1-1 ë˜ëŠ” ì ì‹ ì¤‘1-1 ì²˜ëŸ¼ ì…ë ¥ ê°€ëŠ¥.
    </div>
    <div id="my-hw-status" class="status-text"></div>
  </div>

  <div class="section-card">
    <div class="section-header">
      <div class="section-title">ğŸ“Š ë‚´ ì˜¨ë¼ì¸ ìˆ™ì œ ê²°ê³¼</div>
    </div>

    <div class="unit-result-wrap" id="unit-result-wrap">
      <div class="unit-result-head">
        <div>ë§ˆê° ë‚ ì§œ</div>
        <div>ì¶œì²˜</div>
        <div>êµ¬ë¶„</div>
        <div>ë‹¨ì›(Unit)</div>
        <div>Unit ì „ì²´</div>
        <div>ì œì¶œ ì‹œê°„</div>
      </div>
      <div id="unit-result-body"></div>
    </div>
  </div>

  <div class="section-card">
    <div class="section-header">
      <div class="section-title">ğŸ‘¤ ë‚´ ì •ë³´</div>
    </div>
    <div style="font-size:14px; color:#333;">
      <span style="color:#888; margin-right:6px;">ì´ë¦„:</span><span id="info-name" style="font-weight:700; margin-right:15px;">-</span>
      <span style="color:#888; margin-right:6px;">ë°˜:</span><span id="info-class" style="font-weight:700; margin-right:15px;">-</span>
      <span style="color:#888; margin-right:6px;">ì•„ì´ë””:</span><span id="info-id" style="font-weight:700;">-</span>
    </div>
  </div>
</div>

<div id="manage-backdrop" class="modal-backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="manage-title">
    <div class="modal-head">
      <div class="modal-title" id="manage-title">ğŸ› ï¸ ìˆ™ì œ ê´€ë¦¬ (ìˆ˜ì •/ì‚­ì œ)</div>
      <button id="manage-close" class="btn-mini" style="background:#eee; font-size:14px;">ë‹«ê¸°</button>
    </div>
    <div class="modal-body">
      <div id="manage-area"></div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/@supabase/supabase-js@2.48.0/dist/umd/supabase.js"></script>
<script>
  const SUPABASE_URL = "https://bpdisxjhhibrgfpvtlmv.supabase.co";
  const SUPABASE_ANON_KEY =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJwZGlzeGpoaGlicmdmcHZ0bG12Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5NTkxODQsImV4cCI6MjA3OTUzNTE4NH0.jDZ6BGirOPuWUnt4ykjhng4PLft2ZjBuYAFzApUnlYU";

  const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const infoNameEl   = document.getElementById("info-name");
  const infoClassEl  = document.getElementById("info-class");
  const infoIdEl     = document.getElementById("info-id");
  const classBadgeEl = document.getElementById("class-badge");
  const classHwArea  = document.getElementById("class-hw-area");

  const myHwSetEl     = document.getElementById("my-hw-set");
  const myHwDueEl     = document.getElementById("my-hw-due");
  const myHwSaveBtn   = document.getElementById("my-hw-save-btn");
  const myHwStatusEl  = document.getElementById("my-hw-status");
  const myHwManageBtn = document.getElementById("my-hw-manage-btn");
  const myHwCancelBtn = document.getElementById("my-hw-cancel-btn");

  const typeVocabBtn    = document.getElementById("type-vocab");
  const typeSentenceBtn = document.getElementById("type-sentence");

  const logoutBtn = document.getElementById("logout-btn");
  const homeBtn   = document.getElementById("home-btn");

  const unitResultBody = document.getElementById("unit-result-body");

  const manageBackdrop = document.getElementById("manage-backdrop");
  const manageCloseBtn = document.getElementById("manage-close");
  const manageArea     = document.getElementById("manage-area");

  // âœ… ì–´íœ˜ êµ¬ì„± DOM
  const vocabConfigEl     = document.getElementById("vocab-config");
  const presetDefaultBtn  = document.getElementById("preset-default");
  const presetBlank3Btn   = document.getElementById("preset-blank3");
  const presetResetBtn    = document.getElementById("preset-reset");

  const selMeaning   = document.getElementById("sel-meaning");
  const selEnglish   = document.getElementById("sel-english");
  const selListening = document.getElementById("sel-listening");
  const selSentence  = document.getElementById("sel-sentence");

  const miniMeaning   = document.getElementById("mini-meaning");
  const miniEnglish   = document.getElementById("mini-english");
  const miniListening = document.getElementById("mini-listening");
  const miniSentence  = document.getElementById("mini-sentence");

  let currentStudent = null;
  let currentClass   = null;
  let currentType    = "vocab";
  let editingHomeworkId = null;

  // âœ… ì–´íœ˜ ìˆ™ì œ êµ¬ì„± (ê¸°ë³¸ 1,1,1,1)
  let vocabTasks = { meaning: 1, english: 1, listening: 1, sentence: 1 };

  function setMyHwStatus(msg, type) {
    myHwStatusEl.textContent = msg || "";
    myHwStatusEl.className = "status-text" + (type ? " " + type : "");
  }

  function setSaveButtonMode(isEdit, rowForHint) {
    if (isEdit) {
      myHwSaveBtn.textContent = "ìˆ˜ì • ì €ì¥";
      myHwManageBtn.style.display = "none";
      myHwCancelBtn.style.display = "inline-flex";
      const hint = rowForHint
        ? `âœï¸ ìˆ˜ì •ì¤‘: ${rowForHint.due_date || "-"} / ${rowForHint.set_numbers || "-"}`
        : "âœï¸ ìˆ˜ì • ëª¨ë“œì…ë‹ˆë‹¤.";
      setMyHwStatus(hint, "");
    } else {
      myHwSaveBtn.textContent = "ìˆ™ì œ ë“±ë¡";
      myHwManageBtn.style.display = "inline-flex";
      myHwCancelBtn.style.display = "none";
    }
  }

  function formatDate(iso) {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }
  function formatTime(iso) {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    const hh = String(d.getHours()).padStart(2, "0");
    const mm = String(d.getMinutes()).padStart(2, "0");
    return `${hh}:${mm}`;
  }
  function toDateKey(iso) { return formatDate(iso); }

  function dateKeyFromTitle(title) {
    if (!title) return "";
    const trimmed = title.trim();
    const m = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (m) return `${m[1]}-${m[2]}-${m[3]}`;
    return "";
  }

  function parseUnitKeysFromSetNumbers(setNumbers) {
    if (!setNumbers) return [];
    return String(setNumbers).split(",").map(s => s.trim()).filter(Boolean).map(s => s.replace(/\s+/g, ""));
  }

  function safeLatestBySubmittedAt(arr) {
    const list = (arr || []).filter(x => x && x.submitted_at);
    if (!list.length) return null;
    return list.sort((a,b) => new Date(b.submitted_at) - new Date(a.submitted_at))[0];
  }

  function scoreTextFromResult(r) {
    if (!r) return "--";
    const total = Number(r.total_count || 0);
    const correct = Number(r.correct_count || 0);
    if (!total) return "--";
    const score = Math.round((correct / total) * 100);
    return `${score}ì `;
  }

  function isValidSentenceUnitKey(text) {
    const t = String(text || "").trim();
    if (/^\d+\s*-\s*\d+$/.test(t)) return true;
    if (/^(ì ì‹ ì¤‘|ì ì‹ ê³ )\s*\d+\s*-\s*\d+$/.test(t)) return true;
    return false;
  }

  function parseSetsForSave(setStr, type) {
    const parts = String(setStr || "").split(",").map(s => s.trim()).filter(Boolean);
    if (!parts.length) return null;

    if (type === "vocab") {
      const first = parts[0].split("-");
      if (first.length !== 2) return null;
      const baseLevel = Number(first[0]);
      if (!baseLevel) return null;

      for (const p of parts) {
        const [lvStr, setNumStr] = p.split("-");
        const lv = Number(lvStr);
        const sn = Number(setNumStr);
        if (!lv || !sn || lv !== baseLevel) return null;
      }
      return { level: baseLevel, raw: parts.join(", ") };
    }

    for (const p of parts) if (!isValidSentenceUnitKey(p)) return null;

    let level = 0;
    const m = parts[0].match(/^(\d+)\s*-\s*\d+$/);
    if (m) level = Number(m[1]) || 0;

    const normalized = parts.map(p => p.replace(/\s+/g, ""));
    return { level, raw: normalized.join(", ") };
  }

  function clampNum(v, min, max) {
    const n = Number(v);
    if (Number.isNaN(n)) return min;
    return Math.max(min, Math.min(max, n));
  }

  function syncVocabConfigVisibility() {
    vocabConfigEl.style.display = (currentType === "vocab") ? "block" : "none";
  }

  function applyVocabTasksToUI() {
    selMeaning.value   = String(vocabTasks.meaning ?? 0);
    selEnglish.value   = String(vocabTasks.english ?? 0);
    selListening.value = String(vocabTasks.listening ?? 0);
    selSentence.value  = String(vocabTasks.sentence ?? 0);

    miniMeaning.classList.toggle("off", Number(selMeaning.value) === 0);
    miniEnglish.classList.toggle("off", Number(selEnglish.value) === 0);
    miniListening.classList.toggle("off", Number(selListening.value) === 0);
    miniSentence.classList.toggle("off", Number(selSentence.value) === 0);
  }

  function readVocabTasksFromUI() {
    vocabTasks = {
      meaning: clampNum(selMeaning.value, 0, 5),
      english: clampNum(selEnglish.value, 0, 5),
      listening: clampNum(selListening.value, 0, 5),
      sentence: clampNum(selSentence.value, 0, 5),
    };
    applyVocabTasksToUI();
  }

  function setVocabTasksDefault() { vocabTasks = { meaning:1, english:1, listening:1, sentence:1 }; applyVocabTasksToUI(); }
  function setVocabTasksBlank3()  { vocabTasks = { meaning:0, english:0, listening:0, sentence:3 }; applyVocabTasksToUI(); }
  function setVocabTasksReset()   { vocabTasks = { meaning:0, english:0, listening:0, sentence:0 }; applyVocabTasksToUI(); }

  function normalizeVocabTasksBeforeSave(t) {
    const safe = {
      meaning: clampNum(t.meaning, 0, 5),
      english: clampNum(t.english, 0, 5),
      listening: clampNum(t.listening, 0, 5),
      sentence: clampNum(t.sentence, 0, 5)
    };
    const sum = safe.meaning + safe.english + safe.listening + safe.sentence;
    if (sum === 0) return { meaning:1, english:1, listening:1, sentence:1 };
    return safe;
  }

  function setType(nextType) {
    currentType = nextType;
    if (nextType === "vocab") {
      typeVocabBtn.classList.add("active");
      typeSentenceBtn.classList.remove("active");
    } else {
      typeSentenceBtn.classList.add("active");
      typeVocabBtn.classList.remove("active");
    }
    syncVocabConfigVisibility();
  }
  typeVocabBtn.onclick = () => setType("vocab");
  typeSentenceBtn.onclick = () => setType("sentence");

  async function loadStudentFromLocalStorage() {
    const stored = localStorage.getItem("blossom_student");
    if (!stored) {
      alert("í•™ìƒ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
      window.location.href = "login.html";
      return;
    }
    const s = JSON.parse(stored);
    currentStudent = s;

    infoNameEl.textContent = s.name || "-";
    infoIdEl.textContent   = s.login_id || "-";

    if (!s.class_id) {
      infoClassEl.textContent = "ë¯¸ë°°ì •";
      classBadgeEl.textContent = "ë°˜ ë¯¸ë°°ì •";
      classHwArea.innerHTML =
        '<div class="class-hw-empty">ë°˜ì´ ì•„ì§ ë°°ì •ë˜ì§€ ì•Šì•„ ìˆ™ì œë¥¼ ë³¼ ìˆ˜ ì—†ì–´ìš”.</div>';
      return;
    }

    const { data: cls, error } = await client
      .from("classes")
      .select("id, name")
      .eq("id", s.class_id)
      .maybeSingle();

    if (error) console.error("classes ì¡°íšŒ ì˜¤ë¥˜:", error);

    if (cls) {
      currentClass = cls;
      infoClassEl.textContent = cls.name || "-";
      classBadgeEl.textContent = cls.name;
    } else {
      currentClass = null;
      infoClassEl.textContent = "ë¯¸ë°°ì •";
      classBadgeEl.textContent = "ë°˜ ì •ë³´ ì—†ìŒ";
    }
  }

  async function loadClassHomework() {
    if (!currentClass || !currentClass.id) return;

    classHwArea.innerHTML =
      '<div class="class-hw-empty">ìš°ë¦¬ ë°˜ ìˆ™ì œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>';

    try {
      const classId = currentClass.id;

      const [postsRes, vocabRes, sentenceRes] = await Promise.all([
        client.from("board_posts")
          .select("id, class_id, title, content, created_at")
          .eq("class_id", classId)
          .order("created_at", { ascending: false }),

        client.from("vocab_homework")
          .select("id, class_id, level, set_numbers, due_date, created_at, tasks")
          .eq("class_id", classId)
          .order("created_at", { ascending: false }),

        client.from("sentence_homework")
          .select("id, class_id, level, set_numbers, due_date, created_at, tasks")
          .eq("class_id", classId)
          .order("created_at", { ascending: false })
      ]);

      const groupsMap = {};
      function ensureGroup(dateKey) {
        if (!groupsMap[dateKey]) {
          groupsMap[dateKey] = { dateKey, latestTime: null, posts: [], vocab: [], sentence: [] };
        }
        return groupsMap[dateKey];
      }

      (postsRes.data || []).forEach(row => {
        const dk = dateKeyFromTitle(row.title) || toDateKey(row.created_at);
        if (!dk) return;
        const g = ensureGroup(dk);
        g.posts.push(row);
        if (!g.latestTime || new Date(row.created_at) > new Date(g.latestTime)) g.latestTime = row.created_at;
      });

      (vocabRes.data || []).forEach(row => {
        const baseDate = row.due_date || row.created_at;
        const dk = row.due_date || toDateKey(row.created_at);
        if (!dk) return;
        const g = ensureGroup(dk);
        g.vocab.push(row);
        if (!g.latestTime || new Date(baseDate) > new Date(g.latestTime)) g.latestTime = baseDate;
      });

      (sentenceRes.data || []).forEach(row => {
        const baseDate = row.due_date || row.created_at;
        const dk = row.due_date || toDateKey(row.created_at);
        if (!dk) return;
        const g = ensureGroup(dk);
        g.sentence.push(row);
        if (!g.latestTime || new Date(baseDate) > new Date(g.latestTime)) g.latestTime = baseDate;
      });

      const groups = Object.values(groupsMap).sort((a, b) => new Date(a.dateKey) - new Date(b.dateKey));

      if (!groups.length) {
        classHwArea.innerHTML =
          '<div class="class-hw-empty">ì•„ì§ ìš°ë¦¬ ë°˜ì— ë“±ë¡ëœ ìˆ™ì œê°€ ì—†ì–´ìš”.</div>';
        return;
      }

      classHwArea.innerHTML = "";
      groups.forEach(g => {
        const card = document.createElement("div");
        card.className = "hw-group-card";

        const header = document.createElement("div");
        header.className = "hw-group-header";

        const left = document.createElement("div");
        const dt = document.createElement("div");
        dt.className = "hw-group-date";
        dt.textContent = g.dateKey;
        left.appendChild(dt);

        const chips = document.createElement("div");
        const chipClass = document.createElement("span");
        chipClass.className = "chip chip-class";
        chipClass.textContent = currentClass ? currentClass.name : "ìš°ë¦¬ ë°˜";
        chips.appendChild(chipClass);

        const chipType = document.createElement("span");
        chipType.className = "chip chip-type"; // ë¶„í™ìƒ‰

        const hasOffline = g.posts.length > 0;
        const hasVocab   = g.vocab.length > 0;
        const hasSentence= g.sentence.length > 0;

        if (hasOffline && (hasVocab || hasSentence)) chipType.textContent = "í•„ê¸° + ì˜¨ë¼ì¸ ìˆ™ì œ";
        else if (hasOffline) chipType.textContent = "í•„ê¸° ìˆ™ì œ";
        else chipType.textContent = "ì˜¨ë¼ì¸ ìˆ™ì œ";
        chips.appendChild(chipType);

        left.appendChild(chips);

        const meta = document.createElement("div");
        meta.className = "hw-group-meta";
        meta.textContent = g.latestTime ? `StellaìŒ¤ Â· ${formatDate(g.latestTime)} ${formatTime(g.latestTime)}` : "";

        header.appendChild(left);
        header.appendChild(meta);
        card.appendChild(header);

        if (g.posts.length > 0) {
          const chip = document.createElement("div");
          chip.className = "chip chip-warning";
          chip.textContent = "âœï¸ í•„ê¸° ìˆ™ì œ / ê³µì§€";
          card.appendChild(chip);

          g.posts.forEach(p => {
            const line = document.createElement("div");
            line.className = "hw-text-line";
            line.textContent = p.content || p.title || "";
            card.appendChild(line);
          });
        }

        if (g.vocab.length > 0) {
          const chip = document.createElement("div");
          chip.className = "chip chip-online-vocab";
          chip.textContent = "ì–´íœ˜";
          chip.style.marginTop = "6px";
          card.appendChild(chip);

          g.vocab.forEach(h => {
            const line = document.createElement("div");
            line.className = "hw-text-line";
            const dueTxt = h.due_date ? ` / ë§ˆê°ì¼: ${h.due_date}` : "";
            line.textContent = `ë‹¨ê³„ ${h.level} / ì„¸íŠ¸: ${h.set_numbers}${dueTxt}`;
            card.appendChild(line);
          });
        }

        if (g.sentence.length > 0) {
          const chip = document.createElement("div");
          chip.className = "chip chip-online-sentence";
          chip.textContent = "ë¬¸ì¥";
          chip.style.marginTop = "6px";
          card.appendChild(chip);

          g.sentence.forEach(h => {
            const line = document.createElement("div");
            line.className = "hw-text-line";
            const dueTxt = h.due_date ? ` / ë§ˆê°ì¼: ${h.due_date}` : "";
            line.textContent = `ë‹¨ê³„ ${h.level} / ì„¸íŠ¸: ${h.set_numbers}${dueTxt}`;
            card.appendChild(line);
          });
        }

        classHwArea.appendChild(card);
      });

    } catch (e) {
      console.error("ìš°ë¦¬ ë°˜ ìˆ™ì œ ë¡œë”© ì˜¤ë¥˜:", e);
      classHwArea.innerHTML =
        '<div class="class-hw-empty">ìˆ™ì œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>';
    }
  }

  // âœ… itemsì— tasks í¬í•¨
  function normalizeAndExpandHomeworkRows(row, from) {
    const isStudent = from === "student";
    const type = isStudent ? row.type : (from === "teacher_sentence" ? "sentence" : "vocab");
    const tasks = row?.tasks || null;

    const unitKeys = parseUnitKeysFromSetNumbers(row.set_numbers);

    if (unitKeys.length === 0) {
      return [{
        source: isStudent ? "student" : "teacher",
        sourceLabel: isStudent ? "ë‚´ê°€ ë“±ë¡" : "ì„ ìƒë‹˜",
        type,
        due_date: row.due_date || null,
        created_at: row.created_at || null,
        unit_key: null,
        unit_text: (row.set_numbers || "-"),
        tasks,
        raw: row
      }];
    }

    return unitKeys.map(uk => ({
      source: isStudent ? "student" : "teacher",
      sourceLabel: isStudent ? "ë‚´ê°€ ë“±ë¡" : "ì„ ìƒë‹˜",
      type,
      due_date: row.due_date || null,
      created_at: row.created_at || null,
      unit_key: uk,
      unit_text: uk,
      tasks,
      raw: row
    }));
  }

  // âœ… ë¬¸ì¥ ìƒì„¸ì—ì„œ ì•„ì§ ì“°ëŠ” ì›ë˜ íŒì •ê¸°
  function taskCell(result) {
    if (!result) return { mark: "âŒ", color: "#991b1b", time: "--" };
    const total = Number(result.total_count || 0);
    const correct = Number(result.correct_count || 0);
    const ok = total > 0 && correct >= total;
    return {
      mark: ok ? "â­•" : "â–³",
      color: ok ? "#166534" : "#92400e",
      time: result.submitted_at ? `${formatDate(result.submitted_at)} ${formatTime(result.submitted_at)}` : "--"
    };
  }

  // âœ… ì–´íœ˜: íšŸìˆ˜ ê¸°ë°˜ íŒì •ê¸°
  function taskCellByCount({ doneCount, required, latest }) {
    if (!required || required <= 0) return { mark: "-", color: "#9ca3af", time: "--", progress: "" };

    const done = Number(doneCount || 0);
    const req = Number(required || 0);

    if (done <= 0) return { mark: "âŒ", color: "#991b1b", time: "--", progress: `${done}/${req}` };

    if (done < req) {
      return {
        mark: "â–³",
        color: "#92400e",
        time: latest?.submitted_at ? `${formatDate(latest.submitted_at)} ${formatTime(latest.submitted_at)}` : "--",
        progress: `${done}/${req}`
      };
    }

    return {
      mark: "â­•",
      color: "#166534",
      time: latest?.submitted_at ? `${formatDate(latest.submitted_at)} ${formatTime(latest.submitted_at)}` : "--",
      progress: `${done}/${req}`
    };
  }

  // âœ… ì–´íœ˜ Unit ì „ì²´
  function computeOverallStatusFromVocabModes(modeMap, tasks) {
    if (!tasks) return { cls: "status-x", text: "âŒ" };

    const modes = ["meaning", "english", "listening", "sentence"];
    const requiredModes = modes.filter(m => Number(tasks[m] || 0) > 0);

    if (requiredModes.length === 0) return { cls: "status-x", text: "âŒ" };

    let completed = 0;
    requiredModes.forEach(m => {
      const required = Number(tasks[m]);
      const done = Number(modeMap?.[m]?.doneCount || 0);
      if (done >= required) completed++;
    });

    if (completed === 0) return { cls: "status-x", text: "âŒ" };
    if (completed === requiredModes.length) return { cls: "status-o", text: "â­•" };
    return { cls: "status-d", text: "â–³" };
  }

  const SENTENCE_TASKS_NORMAL = [
    { mode: "blank",   label: "ë¹ˆì¹¸ ì™„ì„±" },
    { mode: "arrange", label: "ë¬¸ì¥ ë°°ì—´" }
  ];
  const SENTENCE_TASKS_SCHOOL = [
    { mode: "school1", label: "í•™êµ ì‹œí—˜ 1" },
    { mode: "school2", label: "í•™êµ ì‹œí—˜ 2" },
    { mode: "school3", label: "í•™êµ ì‹œí—˜ 3" },
    { mode: "school4", label: "í•™êµ ì‹œí—˜ 4" },
    { mode: "school5", label: "í•™êµ ì‹œí—˜ 5" }
  ];
  function isSchoolUnitKey(unitKey) {
    const t = String(unitKey || "");
    return /^(ì ì‹ ì¤‘|ì ì‹ ê³ )\d+-\d+$/.test(t);
  }

  // âœ… sentenceByUnitByMode êµ¬ì¡°ì— ë§ê²Œ ìˆ˜ì •
  function buildSentenceTaskView(unitKey, sentenceByUnitByMode) {
    const modeMap = (sentenceByUnitByMode && sentenceByUnitByMode[unitKey]) ? sentenceByUnitByMode[unitKey] : {};
    const tasks = isSchoolUnitKey(unitKey) ? SENTENCE_TASKS_SCHOOL : SENTENCE_TASKS_NORMAL;

    const rows = tasks.map(t => {
      const pack = modeMap ? modeMap[t.mode] : null;
      const latest = pack?.latest || null;
      const cell = taskCell(latest);
      const hasAny = (pack?.doneCount || 0) > 0;
      return { ...t, pack, hasAny, cell };
    });

    const doneCount = rows.filter(x => x.hasAny).length;
    const totalCount = rows.length;

    const overall = (doneCount === 0)
      ? { cls: "status-x", text: "âŒ" }
      : (doneCount === totalCount)
        ? { cls: "status-o", text: "â­•" }
        : { cls: "status-d", text: "â–³" };

    const latest = safeLatestBySubmittedAt(rows.map(r => r.pack?.latest).filter(Boolean));
    const submittedText = latest
      ? `${scoreTextFromResult(latest)} Â· ${formatDate(latest.submitted_at)} ${formatTime(latest.submitted_at)}`
      : "--";

    return { rows, overall, submittedText };
  }

  // [ìˆ˜ì •] ì‚¬ìš© ëŒ€ì¥(Set)ì„ ë„˜ê²¨ì„œ ì¤‘ë³µ ì‚¬ìš© ë°©ì§€
  function renderUnifiedResults(items, vocabRawMap, sentenceRawMap) {
    unitResultBody.innerHTML = "";

    if (!items || items.length === 0) {
      unitResultBody.innerHTML = '<div class="class-hw-empty">í‘œì‹œí•  ìˆ™ì œê°€ ì—†ì–´ìš”.</div>';
      return;
    }

    // âš¡ ì¤‘ë³µ ë°©ì§€ìš© ì¥ë¶€
    const usedResultIds = new Set();

    items.forEach(item => {
      let modeMap = {};
      
      if (item.type === "vocab" && item.unit_key) {
        const tasks = item.tasks || {}; 
        modeMap = calcStats(vocabRawMap[item.unit_key], item.created_at, tasks, usedResultIds);

      } else if (item.type === "sentence" && item.unit_key) {
        modeMap = calcStats(sentenceRawMap[item.unit_key], item.created_at, null, usedResultIds);
      }

      const details = document.createElement("details");
      details.className = "unit-row";
      details.open = false;

      const summary = document.createElement("summary");
      summary.className = "unit-result-summary";

      const typeChip = document.createElement("span");
      typeChip.className = "chip " + (item.type === "sentence" ? "chip-online-sentence" : "chip-online-vocab");
      typeChip.textContent = item.type === "sentence" ? "ë¬¸ì¥" : "ì–´íœ˜";

      // ì„ ìƒë‹˜/í•™ìƒ ì¶œì²˜ ì¹©ì€ ì‹œê°ì ìœ¼ë¡œ ë³µì¡í•˜ë©´ ìƒëµ ê°€ëŠ¥í•˜ë‚˜ ì¼ë‹¨ ìœ ì§€
      // const srcChip = document.createElement("span");
      // srcChip.className = "chip " + (item.source === "teacher" ? "chip-src-teacher" : "chip-src-student");
      // srcChip.textContent = item.sourceLabel;

      let overall = { cls: "status-x", text: "âŒ" };
      let submittedText = "--";

      // âœ… vocab summary
      if (item.type === "vocab" && item.unit_key) {
        overall = computeOverallStatusFromVocabModes(modeMap, item.tasks);
        const latest = safeLatestBySubmittedAt(
          Object.values(modeMap || {}).map(x => x?.latest).filter(Boolean)
        );
        submittedText = latest
          ? `${scoreTextFromResult(latest)} Â· ${formatDate(latest.submitted_at)} ${formatTime(latest.submitted_at)}`
          : "--";
      }

      // âœ… sentence summary
      if (item.type === "sentence" && item.unit_key) {
        const view = buildSentenceTaskView(item.unit_key, { [item.unit_key]: modeMap }); 
        overall = view.overall;
        submittedText = view.submittedText;
      }

      summary.innerHTML = `
        <div>${item.due_date || "-"}</div>
        <div>${item.sourceLabel}</div>
        <div></div>
        <div>${item.unit_text || "-"}</div>
        <div><span class="status-pill ${overall.cls}">${overall.text}</span></div>
        <div>${submittedText}</div>
      `;
      summary.children[2].appendChild(typeChip);

      const detail = document.createElement("div");
      detail.className = "unit-detail";

      // âœ… vocab detail
      if (item.type === "vocab" && item.unit_key) {
        const tasks = item.tasks || { meaning:1, english:1, listening:1, sentence:1 };

        const tMeaning = taskCellByCount({
          doneCount: modeMap?.meaning?.doneCount || 0,
          required: tasks?.meaning || 0,
          latest: modeMap?.meaning?.latest || null
        });
        const tEnglish = taskCellByCount({
          doneCount: modeMap?.english?.doneCount || 0,
          required: tasks?.english || 0,
          latest: modeMap?.english?.latest || null
        });
        const tListening = taskCellByCount({
          doneCount: modeMap?.listening?.doneCount || 0,
          required: tasks?.listening || 0,
          latest: modeMap?.listening?.latest || null
        });
        const tSentence = taskCellByCount({
          doneCount: modeMap?.sentence?.doneCount || 0,
          required: tasks?.sentence || 0,
          latest: modeMap?.sentence?.latest || null
        });

        detail.innerHTML = `
          <div class="unit-detail-grid">
            <div class="task-row">
              <div class="task-name">ëœ» ì°¾ê¸°</div>
              <div class="task-status" style="color:${tMeaning.color};">${tMeaning.mark} <span style="font-size:12px;color:#6b7280;">${tMeaning.progress}</span></div>
              <div class="task-time">${tMeaning.time}</div>
            </div>
            <div class="task-row">
              <div class="task-name">ì˜ì–´ ì°¾ê¸°</div>
              <div class="task-status" style="color:${tEnglish.color};">${tEnglish.mark} <span style="font-size:12px;color:#6b7280;">${tEnglish.progress}</span></div>
              <div class="task-time">${tEnglish.time}</div>
            </div>
            <div class="task-row">
              <div class="task-name">ë“£ê³  ì°¾ê¸°</div>
              <div class="task-status" style="color:${tListening.color};">${tListening.mark} <span style="font-size:12px;color:#6b7280;">${tListening.progress}</span></div>
              <div class="task-time">${tListening.time}</div>
            </div>
            <div class="task-row">
              <div class="task-name">ë¬¸ì¥ ë¹ˆì¹¸</div>
              <div class="task-status" style="color:${tSentence.color};">${tSentence.mark} <span style="font-size:12px;color:#6b7280;">${tSentence.progress}</span></div>
              <div class="task-time">${tSentence.time}</div>
            </div>
          </div>
          <div style="font-size:12px; color:#999; margin-top:8px;">â€» ê° ëª¨ë“œëŠ” <b>ì„¤ì •ëœ íšŸìˆ˜</b>ë¥¼ ì±„ìš°ë©´ â­•ë¡œ ë°”ë€ë‹ˆë‹¤.</div>
        `;
      } else if (item.type === "sentence" && item.unit_key) {
        const view = buildSentenceTaskView(item.unit_key, { [item.unit_key]: modeMap });

        const grid = document.createElement("div");
        grid.className = "unit-detail-grid";

        view.rows.forEach(r => {
          const row = document.createElement("div");
          row.className = "task-row";
          row.innerHTML = `
            <div class="task-name">${r.label}</div>
            <div class="task-status" style="color:${r.cell.color};">${r.cell.mark}</div>
            <div class="task-time">${r.cell.time}</div>
          `;
          grid.appendChild(row);
        });

        detail.innerHTML = "";
        detail.appendChild(grid);
      } else {
        detail.innerHTML = `
          <div class="unit-detail-grid">
            <div class="task-row">
              <div class="task-name">ê²°ê³¼</div>
              <div class="task-status" style="color:#991b1b;">âŒ</div>
              <div class="task-time">--</div>
            </div>
          </div>
        `;
      }

      details.appendChild(summary);
      details.appendChild(detail);
      unitResultBody.appendChild(details);
    });
  }

  // [ìˆ˜ì •] ê¸°ë¡ í†µì§¸ë¡œ ê°€ì ¸ì˜¤ê¸°
  async function buildResultMap(table, unitKeys) {
    const resultMap = {};
    if (!unitKeys || unitKeys.length === 0) return resultMap;

    const { data, error } = await client
      .from(table)
      .select("id, student_login_id, unit_key, mode, correct_count, total_count, submitted_at")
      .eq("student_login_id", currentStudent.login_id)
      .in("unit_key", unitKeys)
      .order("submitted_at", { ascending: false });

    if (error) throw error;

    (data || []).forEach(r => {
      const uk = r.unit_key;
      if (!uk) return;
      if (!resultMap[uk]) resultMap[uk] = [];
      resultMap[uk].push(r);
    });

    return resultMap;
  }

  // [ìˆ˜ì •] ì„ ì°©ìˆœ ë°°ê¸‰ ë¡œì§
  function calcStats(rawList, sinceDate, requirements, usedSet) {
    const stats = {}; 
    if (!rawList) return stats;

    const since = sinceDate ? new Date(sinceDate) : new Date(0);

    const candidates = rawList.filter(r => {
      if (new Date(r.submitted_at) <= since) return false;
      if (usedSet.has(r.id)) return false;
      return true;
    });

    candidates.sort((a, b) => new Date(a.submitted_at) - new Date(b.submitted_at));

    candidates.forEach(r => {
      const md = r.mode || "unknown";
      
      if (!stats[md]) {
        stats[md] = { doneCount: 0, latest: null };
      }

      const limit = requirements ? (requirements[md] || 0) : 9999;
      
      if (stats[md].doneCount < limit) {
        stats[md].doneCount += 1;
        usedSet.add(r.id);

        const cur = stats[md].latest;
        if (!cur || new Date(r.submitted_at) > new Date(cur.submitted_at)) {
          stats[md].latest = r;
        }
      }
    });

    return stats;
  }

  async function loadUnifiedHomeworkResults() {
    if (!currentStudent || !currentStudent.login_id) return;

    unitResultBody.innerHTML = '<div class="class-hw-empty">ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>';

    try {
      const studentReq = client
        .from("student_homework")
        .select("id, type, level, set_numbers, due_date, created_at, tasks")
        .eq("student_login_id", currentStudent.login_id);

      let teacherVocabReq = Promise.resolve({ data: [], error: null });
      let teacherSentenceReq = Promise.resolve({ data: [], error: null });

      if (currentClass && currentClass.id) {
        teacherVocabReq = client
          .from("vocab_homework")
          .select("id, class_id, level, set_numbers, due_date, created_at, tasks")
          .eq("class_id", currentClass.id);

        teacherSentenceReq = client
          .from("sentence_homework")
          .select("id, class_id, level, set_numbers, due_date, created_at, tasks")
          .eq("class_id", currentClass.id);
      }

      const [studentRes, tvRes, tsRes] = await Promise.all([
        studentReq,
        teacherVocabReq,
        teacherSentenceReq
      ]);

      if (studentRes.error) throw studentRes.error;
      if (tvRes.error) throw tvRes.error;
      if (tsRes.error) throw tsRes.error;

      const items = []
        .concat((studentRes.data || []).flatMap(r => normalizeAndExpandHomeworkRows(r, "student")))
        .concat((tvRes.data || []).flatMap(r => normalizeAndExpandHomeworkRows(r, "teacher_vocab")))
        .concat((tsRes.data || []).flatMap(r => normalizeAndExpandHomeworkRows(r, "teacher_sentence")));

      items.sort((a, b) => {
        const ad = a.due_date ? new Date(a.due_date).getTime() : Number.POSITIVE_INFINITY;
        const bd = b.due_date ? new Date(b.due_date).getTime() : Number.POSITIVE_INFINITY;
        if (ad !== bd) return ad - bd;
        const at = a.created_at ? new Date(a.created_at).getTime() : 0;
        const bt = b.created_at ? new Date(b.created_at).getTime() : 0;
        return at - bt;
      });

      if (!items.length) {
        renderUnifiedResults([], {}, {});
        return;
      }

      const vocabUnitKeys = Array.from(new Set(
        items.filter(x => x.type === "vocab" && x.unit_key).map(x => x.unit_key)
      ));
      const sentenceUnitKeys = Array.from(new Set(
        items.filter(x => x.type === "sentence" && x.unit_key).map(x => x.unit_key)
      ));

      const vocabByUnitByMode = await buildResultMap("vocab_results", vocabUnitKeys);
      const sentenceByUnitByMode = await buildResultMap("sentence_results", sentenceUnitKeys);

      renderUnifiedResults(items, vocabByUnitByMode, sentenceByUnitByMode);

    } catch (e) {
      console.error("í†µí•© ê²°ê³¼ ë¡œë”© ì˜¤ë¥˜:", e);
      unitResultBody.innerHTML = '<div class="class-hw-empty">ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.</div>';
    }
  }

  async function saveMyHomework() {
    if (!currentStudent || !currentStudent.login_id) {
      setMyHwStatus("í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ ì£¼ì„¸ìš”.", "error");
      return;
    }

    const rawSet = myHwSetEl.value.trim();
    const due    = myHwDueEl.value;

    if (!rawSet) { setMyHwStatus("ë‹¨ê³„-ì„¸íŠ¸ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”.", "error"); return; }
    if (!due) { setMyHwStatus("ë§ˆê°ì¼ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.", "error"); return; }

    const parsed = parseSetsForSave(rawSet, currentType);
    if (!parsed) {
      setMyHwStatus(
        currentType === "sentence"
          ? "ë¬¸ì¥ ì„¸íŠ¸ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•„ìš”. ì˜ˆ: 1-1, 11-10 ë˜ëŠ” ì ì‹ ì¤‘1-1"
          : "ì„¸íŠ¸ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•„ìš”. ì˜ˆ: 1-1, 1-2, 1-3",
        "error"
      );
      return;
    }

    setMyHwStatus("", "");
    myHwSaveBtn.disabled = true;

    const tasksForSave = (currentType === "vocab")
      ? normalizeVocabTasksBeforeSave(vocabTasks)
      : null;

    try {
      if (editingHomeworkId) {
        let payload = {
          type: currentType,
          level: parsed.level,
          set_numbers: parsed.raw,
          due_date: due
        };
        if (currentType === "vocab") payload.tasks = tasksForSave;

        let { error } = await client
          .from("student_homework")
          .update(payload)
          .eq("id", editingHomeworkId)
          .eq("student_login_id", currentStudent.login_id);

        if (error) {
          console.error("student_homework ìˆ˜ì • ì˜¤ë¥˜:", error);
          setMyHwStatus("ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”. (ì½˜ì†” ì—ëŸ¬ í™•ì¸)", "error");
          return;
        }

        editingHomeworkId = null;
        setSaveButtonMode(false);
        myHwSetEl.value = "";
        myHwDueEl.value = "";
        if (currentType === "vocab") setVocabTasksDefault();
        setMyHwStatus("âœ… ìˆ˜ì • ì™„ë£Œ!", "");
      } else {
        let payload = {
          student_login_id: currentStudent.login_id,
          type: currentType,
          level: parsed.level,
          set_numbers: parsed.raw,
          due_date: due
        };
        if (currentType === "vocab") payload.tasks = tasksForSave;

        let { error } = await client
          .from("student_homework")
          .insert(payload);

        if (error) {
          if (error.code === "23505") {
            setMyHwStatus(
              "âš ï¸ ê°™ì€ ë§ˆê°ì¼ì— ì´ë¯¸ ê°™ì€ ì¢…ë¥˜ì˜ ìˆ™ì œê°€ ìˆì–´ìš”.\në§ˆê°ì¼ì„ ë°”ê¾¸ê±°ë‚˜ ê¸°ì¡´ ìˆ™ì œë¥¼ ìˆ˜ì •í•´ ì£¼ì„¸ìš”.",
              "error"
            );
            return;
          }
          console.error("student_homework ì €ì¥ ì˜¤ë¥˜:", error);
          setMyHwStatus("ìˆ™ì œë¥¼ ì €ì¥í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”. (ì½˜ì†” ì—ëŸ¬ í™•ì¸)", "error");
          return;
        }

        myHwSetEl.value = "";
        myHwDueEl.value = "";
        if (currentType === "vocab") setVocabTasksDefault();
        setMyHwStatus("âœ… ìˆ™ì œê°€ ë“±ë¡ëì–´ìš”!", "");
      }

      await loadUnifiedHomeworkResults();
      if (currentClass && currentClass.id) await loadClassHomework();
      if (manageBackdrop.style.display === "flex") await loadManageList();

    } catch (e) {
      console.error("student_homework ì €ì¥/ìˆ˜ì • ì˜ˆì™¸:", e);
      setMyHwStatus("ì €ì¥/ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”. (ì½˜ì†” í™•ì¸)", "error");
    } finally {
      myHwSaveBtn.disabled = false;
    }
  }
  myHwSaveBtn.onclick = saveMyHomework;

  function openManageModal() {
    manageBackdrop.style.display = "flex";
    manageBackdrop.setAttribute("aria-hidden", "false");
  }
  function closeManageModal() {
    manageBackdrop.style.display = "none";
    manageBackdrop.setAttribute("aria-hidden", "true");
  }
  manageCloseBtn.onclick = closeManageModal;
  manageBackdrop.addEventListener("click", (e) => {
    if (e.target === manageBackdrop) closeManageModal();
  });
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && manageBackdrop.style.display === "flex") closeManageModal();
  });

  myHwCancelBtn.onclick = () => {
    editingHomeworkId = null;
    setSaveButtonMode(false);
    myHwSetEl.value = "";
    myHwDueEl.value = "";
    setMyHwStatus("ìˆ˜ì •ì´ ì·¨ì†Œëì–´ìš”.", "");
    setVocabTasksDefault();
  };

  function fillFormForEdit(row) {
    editingHomeworkId = String(row.id);
    myHwSetEl.value = row.set_numbers || "";
    myHwDueEl.value = row.due_date || "";
    setType(row.type === "sentence" ? "sentence" : "vocab");
    setSaveButtonMode(true, row);

    if (row.type !== "vocab") return;
  }

  function bindManageButtons() {
    document.addEventListener("click", async (e) => {
      const btn = e.target.closest("button.btn-mini[data-act]");
      if (!btn) return;
      if (!manageBackdrop || manageBackdrop.style.display !== "flex") return;

      e.preventDefault();
      e.stopPropagation();

      const act = btn.dataset.act;
      const rowJson = btn.dataset.row || "";
      const id = String(btn.dataset.id || "");

      if (act === "edit") {
        const row = rowJson ? JSON.parse(rowJson) : null;
        if (!row) return;
        fillFormForEdit(row);
        closeManageModal();
        return;
      }

      if (act === "delete") {
        const ok = confirm("ì •ë§ ì‚­ì œí• ê¹Œìš”?");
        if (!ok) return;

        const { error: delErr } = await client
          .from("student_homework")
          .delete()
          .eq("id", id)
          .eq("student_login_id", currentStudent.login_id);

        if (delErr) {
          console.error("ì‚­ì œ ì˜¤ë¥˜:", delErr);
          alert("ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.");
          return;
        }

        if (editingHomeworkId === id) {
          editingHomeworkId = null;
          setSaveButtonMode(false);
          myHwSetEl.value = "";
          myHwDueEl.value = "";
          setVocabTasksDefault();
        }

        await loadManageList();
        await loadUnifiedHomeworkResults();
        if (currentClass && currentClass.id) await loadClassHomework();
      }
    }, true);
  }

  async function loadManageList() {
    if (!currentStudent || !currentStudent.login_id) return;

    manageArea.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>';

    const { data, error } = await client
      .from("student_homework")
      .select("id, type, level, set_numbers, due_date, created_at, tasks")
      .eq("student_login_id", currentStudent.login_id)
      .order("due_date", { ascending: true })
      .order("created_at", { ascending: true });

    if (error) {
      console.error("student_homework ëª©ë¡ ì˜¤ë¥˜:", error);
      manageArea.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”.</div>';
      return;
    }

    if (!data || data.length === 0) {
      manageArea.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">ì•„ì§ ë“±ë¡í•œ ìˆ™ì œê°€ ì—†ì–´ìš”.</div>';
      return;
    }

    const table = document.createElement("table");
    table.className = "manage-table";

    table.innerHTML = `
      <thead>
        <tr>
          <th style="width:140px;">ë§ˆê°ì¼</th>
          <th style="width:90px;">êµ¬ë¶„</th>
          <th>ì„¸íŠ¸</th>
          <th style="width:120px; text-align:right;">ê´€ë¦¬</th>
        </tr>
      </thead>
      <tbody></tbody>
    `;

    const tbody = table.querySelector("tbody");

    data.forEach(row => {
      const tr = document.createElement("tr");

      const tdDate = document.createElement("td");
      tdDate.innerHTML = `<span style="color:var(--blue); font-weight:800;">${row.due_date || "-"}</span>`;
      tr.appendChild(tdDate);

      const tdType = document.createElement("td");
      const chip = document.createElement("span");
      chip.className = "chip " + (row.type === "sentence" ? "chip-online-sentence" : "chip-online-vocab");
      chip.textContent = row.type === "sentence" ? "ë¬¸ì¥" : "ì–´íœ˜";
      tdType.appendChild(chip);
      tr.appendChild(tdType);

      const tdSet = document.createElement("td");
      tdSet.textContent = row.set_numbers || "-";
      tr.appendChild(tdSet);

      const tdAct = document.createElement("td");
      tdAct.style.textAlign = "right";

      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.className = "btn-mini btn-edit";
      editBtn.textContent = "ìˆ˜ì •";
      editBtn.dataset.act = "edit";
      editBtn.dataset.id = String(row.id);
      editBtn.dataset.row = JSON.stringify(row);

      const delBtn = document.createElement("button");
      delBtn.type = "button";
      delBtn.className = "btn-mini btn-del";
      delBtn.textContent = "ì‚­ì œ";
      delBtn.dataset.act = "delete";
      delBtn.dataset.id = String(row.id);

      tdAct.appendChild(editBtn);
      tdAct.appendChild(delBtn);
      tr.appendChild(tdAct);

      tbody.appendChild(tr);
    });

    manageArea.innerHTML = "";
    manageArea.appendChild(table);
  }

  myHwManageBtn.onclick = async () => {
    if (!currentStudent || !currentStudent.login_id) {
      alert("í•™ìƒ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
      return;
    }
    openManageModal();
    await loadManageList();
  };

  logoutBtn.onclick = () => {
    localStorage.removeItem("blossom_student");
    window.location.href = "index.html";
  };
  homeBtn.onclick = () => { window.location.href = "index.html"; };

  function bindVocabConfig() {
    setVocabTasksDefault();
    syncVocabConfigVisibility();

    selMeaning.addEventListener("change", readVocabTasksFromUI);
    selEnglish.addEventListener("change", readVocabTasksFromUI);
    selListening.addEventListener("change", readVocabTasksFromUI);
    selSentence.addEventListener("change", readVocabTasksFromUI);

    presetDefaultBtn.addEventListener("click", setVocabTasksDefault);
    presetBlank3Btn.addEventListener("click", setVocabTasksBlank3);
    presetResetBtn.addEventListener("click", setVocabTasksReset);
  }

  (async function init() {
    bindManageButtons();
    bindVocabConfig();
    await loadStudentFromLocalStorage();
    if (currentClass && currentClass.id) await loadClassHomework();
    await loadUnifiedHomeworkResults();
    setSaveButtonMode(false);
    setType("vocab");
    myHwDueEl.value = new Date().toISOString().split('T')[0]; // ë§ˆê°ì¼ ì˜¤ëŠ˜ë¡œ ì„¸íŒ…
  })();
</script>
</body>
</html>
